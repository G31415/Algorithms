// poj1700 Crossing River

// 大意：N个人过河。船每次最多仅仅能坐两个人。船载每一个人过河的所需时间不同，问最快的过河时间。

// 当n = 1, 2, 3时所须要的最小时间非常easy求得, 如今由n >= 4, 如果n个人过河所需时间存储在数组t中,
// 将数组t按升序排序, 那么 这时将单独过河所须要时间最多的两个旅行者送到对岸去, 有两种方式 :
// 1. 最快的(即所用时间t[0]) 和次快的过河, 然后最快的将船划回来, 再次慢的和最慢的过河, 然后次快的将船划回来.
//    即所需时间为 : t[0] + 2 * t[1] + t[n - 1]
// 2. 最快的和最慢的过河,然后最快的将船划回来, 再最快的和次慢的过河, 然后最快的将船划回来.
//    即所需时间为 : 2 * t[0] + t[n - 2] + t[n - 1]

//    这样就将过河所需时间最大的两个人送过了河,
//    而对于剩下的人, 採用相同的处理方式, 接下来做的就是推断如何用的时间最少.

#include <iostream>
#include <algorithm>

using namespace std;

int main()
{
    int m, n, t[1001], i, sum;
    cin >> m;
    while (m--)
    {
        cin >> n;
        sum = 0;
        for (i = 0; i < n; i++)
            cin >> t[i];
        sort(t, t + n);
        for (i = n - 1; i > 2; i -= 2)
            if (t[0] + 2 * t[1] + t[i] > 2 * t[0] + t[i - 1] + t[i])
                sum += 2 * t[0] + t[i - 1] + t[i];
            else
                sum += t[0] + 2 * t[1] + t[i];
        if (i == 2)
            sum += t[0] + t[1] + t[2];
        else if (i == 1)
            sum += t[1];
        else
            sum += t[0];
        cout << sum << endl;
    }
    return 0;
}
